# fastlane/Fastfile
default_platform(:all)

platform :all do

  #########################################
  # ========== HELPERS G√âN√âRAUX ==========
  #########################################

  def flutter(*args)
    sh("flutter #{args.join(' ')}")
  end

  # Dossier screenshots
  def screenshots_dir
    File.join("test_driver", "screenshots")
  end

  # Nettoyage build sauf fichiers sensibles
  def clean_build!
    sh("git clean -xfd \
        -e build \
        -e ios/Pods \
        -e android/.gradle \
        -e android/app/google-services.json \
        -e ios/Runner/GoogleService-Info.plist || true")
  end

  #########################################
  # ============ METADATA LANE ============
  #########################################

  desc "üì∏ G√©n√©rer les m√©tadonn√©es Android & iOS"
  lane :generate_metadata do
    project_root = File.expand_path("..", __dir__)
    dart_script_android = File.join(project_root, "fastlane/generate_metadata_android.dart")
    dart_script_ios     = File.join(project_root, "fastlane/generate_metadata_ios.dart")

    UI.user_error!("‚ùå Script Dart android introuvable: #{dart_script_android}") unless File.exist?(dart_script_android)
    UI.user_error!("‚ùå Script Dart iOS introuvable: #{dart_script_ios}")       unless File.exist?(dart_script_ios)

    UI.message("üß† G√©n√©ration des m√©tadonn√©es Android...")
    Dir.chdir(project_root) { sh("dart '#{dart_script_android}'") }

    UI.message("üß† G√©n√©ration des m√©tadonn√©es iOS...")
    Dir.chdir(project_root) { sh("dart '#{dart_script_ios}'") }
  end

  #########################################
  # =============== LANES ================
  #########################################

  desc "üì∑ Screenshots iOS (simulateur) ‚Äî build unique + config runtime (Option 3)"
  lane :screenshots_ios do |options|
    project_root    = File.expand_path("..", __dir__)
    shots_dir       = File.join(project_root, screenshots_dir)
    FileUtils.mkdir_p(shots_dir)

    ios_udid = options[:udid] || "DFE799EA-B2F9-4EBA-BEC7-13970400A07E" # adapte si besoin

    clean_build!
    ensure_firebase_files_present!
    generate_metadata

    # Build iOS (target driver) si absent/incorrect (avec marqueur)
    ensure_ios_simulator_built_once!

    # Boot du simulateur + d√©sinstallation app (√©vite Runner sans Driver)
    start_ios_simulator_by_udid(ios_udid)
    uninstall_ios_app(ios_udid, ios_bundle_id)

    ios_folders = [
      "iphone6_7_inch",
      "iPad Pro (12.9-inch) (3rd generation)",
      "ipad_12_9_inch"
    ]

    locales = extract_locales
    UI.user_error!("‚ùå Aucune locale trouv√©e") if locales.empty?

    ios_folders.each do |dest_folder|
      locales.each do |locale|
        purge_screenshots_dir!(shots_dir)
        UI.message("üì∏ iOS ‚Äî locale=#{locale}, dest=#{dest_folder}")

        env = "PLATFORM=ios LOCALE=#{locale} DESTFOLDER='#{dest_folder}' FOR_FEATURE_GRAPHIC=false"
        cmd = %Q{
          #{env} caffeinate -s flutter drive \
            --no-dds \
            --driver=test_driver/integration_test.dart \
            --target=test_driver/app.dart \
            --no-build \
            --use-application-binary="#{ios_sim_runner_app_path}" \
            -d #{ios_udid} \
            --screenshot="#{shots_dir}"
        }.strip

        ok = run_drive_with_retries!(cmd: cmd, retries: 2, locale: locale, dest_folder: dest_folder, shots_dir: shots_dir)
        unless ok
          UI.important("‚è≠Ô∏è Skip #{locale}/#{dest_folder} apr√®s √©checs.")
          next
        end

        clean_driver_artifacts!(shots_dir)
        copy_screenshots_to_metadata(
          platform_store: "ios",
          locale: locale,
          dest_folder: dest_folder,
          screenshots_dir: shots_dir,
          project_root: project_root
        )
      end
    end

    UI.success("‚úÖ Screenshots iOS termin√©s")
  end

  desc "üì∑ Screenshots Android ‚Äî build unique + config runtime (Option 3) + r√©glage r√©solution (+ reboot par bucket)"
  lane :screenshots_android do |options|
    project_root    = File.expand_path("..", __dir__)
    shots_dir       = File.join(project_root, screenshots_dir)
    FileUtils.mkdir_p(shots_dir)

    avd_name = options[:avd] || "emulator_tablet_10pouces_screenshots_voczilla"

    clean_build!
    ensure_firebase_files_present!
    generate_metadata

    # Build Android (target driver) si absent/incorrect (avec marqueur)
    ensure_android_built_once!(:debug)

    # Buckets Play Store
    android_folders = [
     # "FeatureGraphic",
      "phoneScreenshots",
      "sevenInchScreenshots",
      "tenInchScreenshots"
    ]

    locales = extract_locales
    UI.user_error!("‚ùå Aucune locale trouv√©e") if locales.empty?

    android_folders.each do |dest_folder|
      # üîÑ Reboot propre de l'√©mulateur √† chaque bucket pour la stabilit√©
      stop_emulator
      start_emulator_once(avd_name)
      emulator_id = get_running_emulator_id
      tune_android_emulator_for_tests(emulator_id) if emulator_id
      uninstall_android_app(android_package_name, emulator_id) if emulator_id
      set_emulator_resolution(emulator_id, dest_folder)

      locales.each do |locale|
        purge_screenshots_dir!(shots_dir)
        is_feature = (dest_folder == "FeatureGraphic")
        UI.message("üì∏ Android ‚Äî locale=#{locale}, dest=#{dest_folder}")

        env = "PLATFORM=android LOCALE=#{locale} DESTFOLDER='#{dest_folder}' FOR_FEATURE_GRAPHIC=#{is_feature}"
        cmd = %Q{
          #{env} caffeinate -s flutter drive \
            --no-dds \
            --driver=test_driver/integration_test.dart \
            --target=test_driver/app.dart \
            --no-build \
            --use-application-binary="#{android_apk_debug_path}" \
            -d #{emulator_id} \
            --screenshot="#{shots_dir}"
        }.strip

        ok = run_drive_with_retries!(cmd: cmd, retries: 2, locale: locale, dest_folder: dest_folder, shots_dir: shots_dir, emulator_id: emulator_id)
        unless ok
          UI.important("‚è≠Ô∏è Skip #{locale}/#{dest_folder} apr√®s √©checs.")
          next
        end

        clean_driver_artifacts!(shots_dir)
        copy_screenshots_to_metadata(
          platform_store: "android",
          locale: locale,
          dest_folder: dest_folder,
          screenshots_dir: shots_dir,
          project_root: project_root
        )
      end

      reset_emulator_resolution(emulator_id)
      # on ne stoppe pas ici : il sera red√©marr√© au prochain bucket
    end

    stop_emulator
    UI.success("‚úÖ Screenshots Android termin√©s")
  end

  desc "üì∑ Screenshots (iOS + Android) ‚Äî orchestrateur"
  lane :screenshots do
    screenshots_android
    screenshots_ios

    # Nettoyage disque apr√®s ex√©cution
    free = disk_free_gb(".")
    aggressive = free < env_threshold_gb
    UI.message("üíæ Espace libre: #{free} GB (seuil: #{env_threshold_gb} GB) ‚Üí cleanup #{aggressive ? "AGRESSIF" : "s√©lectif"}")
    cleanup_builds(keep_ios_build: true, aggressive: aggressive)

    UI.success("üéâ Screenshots multi-plateforme termin√©s")
  end

  desc "üßΩ Nettoyage manuel (l√©ger)"
  lane :cleanup_soft do
    cleanup_builds(keep_ios_build: true, aggressive: false)
  end

  desc "üî• Nettoyage agressif"
  lane :cleanup_hard do
    cleanup_builds(keep_ios_build: false, aggressive: true)
  end
end

# ================= Helpers =================

require "tmpdir"

# ----- Wrapper retries (2) + logs + mitigations -----
def run_drive_with_retries!(cmd:, retries:, locale:, dest_folder:, shots_dir:, emulator_id: nil)
  attempts = retries.to_i + 1
  (1..attempts).each do |i|
    begin
      UI.message("üöó flutter drive tentative #{i}/#{attempts} ‚Üí #{locale}/#{dest_folder}")
      sh(cmd)
      return true
    rescue => e
      UI.error("‚ùå Tentative #{i} √©chou√©e: #{e.message}")

      # Dump logcat si Android
      if emulator_id && !emulator_id.to_s.empty?
        sh("adb -s #{emulator_id} logcat -d | tail -n 500 || true")
        sh("adb -s #{emulator_id} logcat -c || true")
      end

      if i < attempts
        UI.message("üßπ Mitigation rapide avant retry‚Ä¶")
        clean_driver_artifacts!(shots_dir)
        sleep(2)
      end
    end
  end
  false
end

# ----- Nettoyage des captures parasites g√©n√©r√©es par flutter drive -----
def clean_driver_artifacts!(screenshots_dir, patterns: ['driver_*.png', 'drive_*.png'])
  patterns.each do |glob|
    Dir[File.join(screenshots_dir, glob)].each do |f|
      UI.message("üóë Suppression fichier parasite: #{f}")
      FileUtils.rm_f(f)
    end
  end
end

# ----- Purge du dossier screenshots (√† chaque langue) -----
def purge_screenshots_dir!(dir_path)
  UI.message("üßπ Purge du dossier de screenshots: #{dir_path}")
  FileUtils.mkdir_p(dir_path)
  Dir[File.join(dir_path, "*")].each { |f| FileUtils.rm_f(f) }
end

# ---- Marqueurs de build (garantit target driver) ----
def android_driver_marker_path
  File.expand_path("../build/.driver_android_ok", __dir__)
end

def ios_driver_marker_path
  File.expand_path("../build/.driver_ios_ok", __dir__)
end

def write_marker(path)
  FileUtils.mkdir_p(File.dirname(path))
  File.write(path, "driver_target=test_driver/app.dart\n")
end

def marker_ok?(path)
  File.exist?(path) && File.read(path).include?("driver_target=test_driver/app.dart")
end

# ---- Garde-fou Firebase ----
def ensure_firebase_files_present!
  project_root = File.expand_path("..", __dir__)
  files = {
    "android/app/google-services.json"    => "Firebase Android (google-services.json)",
    "ios/Runner/GoogleService-Info.plist" => "Firebase iOS (GoogleService-Info.plist)"
  }
  missing = []
  files.each do |path, description|
    full = File.join(project_root, path)
    unless File.exist?(full)
      UI.important("‚ö†Ô∏è Fichier manquant : #{description} ‚Üí #{full}")
      missing << description
    end
  end
  UI.user_error!("‚ùå Fichiers Firebase manquants : #{missing.join(', ')}") if missing.any?
  UI.message("‚úÖ Fichiers Firebase pr√©sents.")
end

# ---- Disque ----
def disk_free_gb(path=".")
  out = sh(%Q{df -k "#{path}" | tail -1 | awk '{print $4}'}, log: false).strip.to_i
  (out / 1024.0 / 1024.0).round(1)
end

def env_threshold_gb
  (ENV["FASTLANE_DISK_THRESHOLD_GB"] || "10").to_f
end

# ---- Chemins binaires ----
def ios_sim_runner_app_path
  File.expand_path("../build/ios/iphonesimulator/Runner.app", __dir__)
end

def android_apk_debug_path
  File.expand_path("../build/app/outputs/flutter-apk/app-debug.apk", __dir__)
end

def android_apk_release_path
  File.expand_path("../build/app/outputs/flutter-apk/app-release.apk", __dir__)
end

# ---- Identifiants app ----
def android_package_name
  "com.geoffreypetain.voczilla.voczilla"
end

def ios_bundle_id
  "com.geoffreypetain.voczilla.voczilla"
end

# ---- Builds uniques (target driver) + marqueurs ----
def ensure_ios_simulator_built_once!
  app_path = ios_sim_runner_app_path
  if File.exist?(app_path) && marker_ok?(ios_driver_marker_path)
    UI.message("üü¢ Build iOS (simulateur) d√©j√† pr√©sent (driver target) ‚Üí OK.")
    return app_path
  end
  UI.message("üì¶ Build iOS simulateur depuis test_driver/app.dart...")
  no_codesign = (ENV["IOS_CODESIGN"] == "false")
  cmd = "flutter build ios --simulator -t test_driver/app.dart"
  cmd += " --no-codesign" if no_codesign
  flutter(cmd.gsub(/^flutter /, "")) # via helper
  write_marker(ios_driver_marker_path)
  app_path
end

def ensure_android_built_once!(mode = :debug)
  target_path = (mode == :release) ? android_apk_release_path : android_apk_debug_path
  if File.exist?(target_path) && marker_ok?(android_driver_marker_path)
    UI.message("üü¢ Build Android (#{mode}) d√©j√† pr√©sent (driver target) ‚Üí OK.")
    return target_path
  end
  UI.message("üì¶ Build Android APK (#{mode}) depuis test_driver/app.dart...")
  track = (mode == :release) ? "--release" : "--debug"
  flutter("build apk #{track} -t test_driver/app.dart")
  write_marker(android_driver_marker_path)
  target_path
end

# ----- iOS Simulators -----
def start_ios_simulator_by_udid(udid)
  is_booted = sh(%Q{xcrun simctl list devices | grep -F "#{udid}"}, log: false).include?("(Booted)")
  sh("xcrun simctl boot #{udid}") unless is_booted
  sh("open -a Simulator --args -CurrentDeviceUDID #{udid} || true")
  sh("xcrun simctl bootstatus #{udid} -b")
end

def uninstall_ios_app(udid, bundle_id)
  return if udid.to_s.empty? || bundle_id.to_s.empty?
  UI.message("üóëÔ∏è D√©sinstallation iOS de #{bundle_id} sur #{udid}")
  sh("xcrun simctl uninstall #{udid} #{bundle_id} || true")
end

# ----- Android emulator (robuste) -----
def get_running_emulator_id
  out = sh("adb devices", log: false) rescue ""
  line = out.lines.find { |l| l.start_with?("emulator-") && l.include?("\tdevice") }
  line&.split("\t")&.first
end

def start_emulator_once(avd_name)
  existing = get_running_emulator_id
  if existing
    UI.message("üü¢ √âmulateur d√©j√† d√©marr√©: #{existing}")
    ensure_android_booted(existing)
    return existing
  end

  sh("adb start-server || true")

  emulator_cmd = [
    File.join(ENV['ANDROID_HOME'], "emulator", "emulator"),
    "-avd", avd_name,
    "-no-snapshot-load",
    "-no-audio"
  ]
  Process.spawn(*emulator_cmd, [:out, :err] => "/dev/null")

  UI.message("‚åõ Attente de connexion ADB √† l'√©mulateur...")
  emulator_id = nil
  48.times do
    sleep(5)
    emulator_id = get_running_emulator_id
    break if emulator_id
  end
  UI.user_error!("‚ùå L'√©mulateur n'a pas √©t√© d√©tect√© par ADB.") unless emulator_id

  ensure_android_booted(emulator_id)
  emulator_id
end

def ensure_android_booted(emulator_id)
  UI.message("‚öôÔ∏è Attente de boot complet Android pour #{emulator_id}...")
  sh("adb -s #{emulator_id} wait-for-device || true")

  # Couper les animations
  %w[animator_duration_scale transition_animation_scale window_animation_scale].each do |k|
    sh("adb -s #{emulator_id} shell settings put global #{k} 0 || true", log: false)
  end

  # Boucle d'attente tol√©rante
  120.times do
    boot_status = sh("adb -s #{emulator_id} shell getprop sys.boot_completed || true", log: false).strip
    anim_state  = sh("adb -s #{emulator_id} shell getprop init.svc.bootanim || true", log: false).strip
    break if (boot_status == "1") || (anim_state == "stopped")
    sleep(2)
  end

  echo_ok = sh("adb -s #{emulator_id} shell echo ok || true", log: false).strip
  UI.user_error!("‚ùå L'√©mulateur #{emulator_id} ne r√©pond pas correctement.") unless echo_ok == "ok"
end

def stop_emulator
  emulator_id = get_running_emulator_id
  return unless emulator_id
  sh("adb -s #{emulator_id} emu kill")
  sleep(5)
end

def reset_emulator_resolution(emulator_id)
  sh("adb -s #{emulator_id} shell wm size reset && adb -s #{emulator_id} shell wm density reset")
end

def set_emulator_resolution(emulator_id, dest_folder)
  resolution_map = {
    "phoneScreenshots"      => ["1080x1920", "420"],
    "sevenInchScreenshots"  => ["800x1280",  "213"],
    "tenInchScreenshots"    => ["1600x2560", "320"],
    "FeatureGraphic"        => ["1024x500",  "160"],
    # cl√©s iOS (ignor√©es c√¥t√© Android)
    "iphone6_7_inch"                        => nil,
    "ipad_12_9_inch"                        => nil,
    "iPad Pro (12.9-inch) (3rd generation)" => nil
  }

  size, density = (resolution_map[dest_folder] || [nil, nil])
  if size && density
    sh("adb -s #{emulator_id} shell wm size #{size} && adb -s #{emulator_id} shell wm density #{density}")
  elsif resolution_map.key?(dest_folder)
    # no-op (cl√© iOS)
  else
    UI.error("Unsupported size: #{dest_folder}")
  end
end

# üëâ Boost perfs tests/screenshots Android
def tune_android_emulator_for_tests(emulator_id)
  return unless emulator_id && !emulator_id.strip.empty?

  UI.message("üöÄ Optimisation de l'√©mulateur #{emulator_id} (animations OFF, perf tweaks)...")

  %w[animator_duration_scale transition_animation_scale window_animation_scale].each do |k|
    sh("adb -s #{emulator_id} shell settings put global #{k} 0 || true", log: false)
  end
  sh("adb -s #{emulator_id} shell settings put system screen_off_timeout 2147483647 || true", log: false)
  sh("adb -s #{emulator_id} shell settings put system accelerometer_rotation 0 || true", log: false)
  sh("adb -s #{emulator_id} shell settings put system user_rotation 0 || true", log: false)
  sh("adb -s #{emulator_id} shell settings put system show_touches 0 || true", log: false)
end

# ----- D√©sinstallation Android -----
def uninstall_android_app(package_name, emulator_id)
  return if emulator_id.to_s.empty? || package_name.to_s.empty?
  UI.message("üóëÔ∏è Uninstall √©ventuel de #{package_name} sur #{emulator_id}")
  sh("adb -s #{emulator_id} uninstall #{package_name} || true")
end

# ----- Locales -----
def extract_locales
  project_root = File.expand_path("..", __dir__)
  arb_files = Dir[File.join(project_root, "lib/l10n/app_*.arb")]
  locales = arb_files.map { |f| f.match(/app_(.+)\.arb$/)&.captures&.first }.compact.uniq
  UI.user_error!("‚ùå Aucune locale trouv√©e dans les fichiers ARB.") if locales.empty?
  locales
end

# ----- Copie des screenshots vers metadata -----
def copy_screenshots_to_metadata(platform_store:, locale:, dest_folder:, screenshots_dir:, project_root:)
  clean_driver_artifacts!(screenshots_dir) # supprime driver_*.png & drive_*.png
  screenshots = Dir[File.join(screenshots_dir, "*.png")]

  normalized_locale = get_normalized_locale(locale, platform_store)
  if normalized_locale.nil?
    UI.important("‚ö†Ô∏è Locale #{locale} non support√©e pour #{platform_store}. Ignor√©e pour la copie.")
    return
  end

  relative_metadata =
    if platform_store == "android" && dest_folder == "FeatureGraphic"
      File.join(platform_store, normalized_locale, "images")
    elsif platform_store == "ios"
      File.join(platform_store, normalized_locale)
    else # android classique
      File.join(platform_store, normalized_locale, "images", dest_folder)
    end

  dest_dir_project = File.join(project_root, "fastlane/metadata", relative_metadata)
  dest_dir_symlink = File.join("/Volumes/data/voczilla/metadata", relative_metadata)

  [dest_dir_project, dest_dir_symlink].each do |dest_dir|
    UI.message("üìÅ Copie des captures vers : #{dest_dir}")
    FileUtils.mkdir_p(dest_dir)
    screenshots.empty? ? UI.important("Aucune capture √† copier pour #{locale}") : FileUtils.cp(screenshots, dest_dir)
  end
end

# ----- Bridge Dart pour normaliser les locales -----
def get_normalized_locale(locale, platform)
  project_root = File.expand_path("..", __dir__)
  map_script   = File.join(project_root, "fastlane/invoke_locale_mapper.dart")
  UI.user_error!("‚ùå Script de mapping de locale introuvable: #{map_script}") unless File.exist?(map_script)

  normalized = sh("dart \"#{map_script}\" #{platform} #{locale}", log: false).strip
  return normalized.empty? ? nil : normalized
end

# ----- Nettoyage espace disque -----
def cleanup_builds(keep_ios_build:, aggressive:)
  UI.message("üßΩ Nettoyage (keep_ios_build=#{keep_ios_build}, aggressive=#{aggressive})")

  # Android
  sh("rm -rf .dart_tool/ .gradle/ android/.gradle/ build/app || true")

  # iOS
  if aggressive
    sh("rm -rf build/ios || true")
    sh("rm -rf ~/Library/Developer/Xcode/DerivedData/* || true")
  else
    if keep_ios_build && File.exist?(ios_sim_runner_app_path)
      tmp = File.join(Dir.tmpdir, "Runner.app.backup.#{Time.now.to_i}")
      FileUtils.mkdir_p(File.dirname(tmp))
      FileUtils.mv(ios_sim_runner_app_path, tmp)
      sh("rm -rf build/ios || true")
      sh("rm -rf ~/Library/Developer/Xcode/DerivedData/* || true")
      FileUtils.mkdir_p(File.dirname(ios_sim_runner_app_path))
      FileUtils.mv(tmp, ios_sim_runner_app_path)
      UI.message("‚úÖ Runner.app conserv√© (iOS simulateur)")
    else
      sh("rm -rf build/ios || true")
      sh("rm -rf ~/Library/Developer/Xcode/DerivedData/* || true")
    end
  end

  # Simulateurs iOS obsol√®tes
  sh("xcrun simctl delete unavailable || true")
end
